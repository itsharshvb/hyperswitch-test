name: API Schema Compatibility Check

# This workflow:
# - Runs on ALL PRs that modify API-related files
# - Comments on PRs ONLY when 'validate-api' label is present
# - Always fails if breaking changes are detected (regardless of label)

on:
  pull_request:
    paths:
      - 'crates/api_models/**'
      - 'crates/openapi/**'
      - 'crates/router/**'
      - 'api-reference/**'
      - '.oasdiff-config.yaml'
      - 'migrations/**'
      - 'v2_migrations/**'
      - 'v2_compatible_migrations/**'
    types: [opened, synchronize, reopened, labeled, unlabeled]

  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  api-compatibility-check:
    name: add `validate-api` label to PRs for details
    runs-on: ubuntu-latest
    
    # Run on all PRs that modify API-related files
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          token: ${{ github.token }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable 2 weeks ago
          
      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          # Cache key based on Cargo files
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          # Cache the target directory
          cache-targets: true
          # Cache cargo registry
          cache-all-crates: true

      - name: Setup Node.js for validation tools
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install system dependencies
        run: |
          # Install jq for JSON validation and processing
          sudo apt-get update && sudo apt-get install -y jq

      - name: Setup Go for oasdiff
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          
      - name: Install validation tools
        run: |
          # Install oasdiff using Go with correct module path
          go install github.com/oasdiff/oasdiff@latest

          # Add Go bin to PATH for current session
          echo "$HOME/go/bin" >> $GITHUB_PATH

          # Verify installation
          echo "oasdiff installation completed"
          
      - name: Verify oasdiff installation
        run: |
          # Verify oasdiff is accessible
          export PATH="$HOME/go/bin:$PATH"
          oasdiff --version || oasdiff --help | head -5

      - name: Generate current API schemas
        env:
          # Speed up compilation - disable incremental compilation and debug info
          CARGO_INCREMENTAL: 0
          RUSTFLAGS: "-C debuginfo=0"
        run: |
          echo "Generating API schemas for current PR..."
          
          # Generate V1 schema
          echo "Building V1 schema..."
          cargo run -p openapi --features v1 2>&1
          
          # Generate V2 schema
          echo "Building V2 schema..."
          cargo run -p openapi --features v2 2>&1
          
          # Verify and copy generated schemas
          echo "Verifying generated schema files..."
          
          if [[ -f "api-reference/v1/openapi_spec_v1.json" ]]; then
            # Validate JSON before copying
            if jq empty api-reference/v1/openapi_spec_v1.json 2>/dev/null; then
              cp api-reference/v1/openapi_spec_v1.json pr-v1-schema.json
              echo "✅ V1 schema: $(wc -c < pr-v1-schema.json) bytes (valid JSON)"
            else
              echo "❌ V1 schema contains invalid JSON"
              echo "{}" > pr-v1-schema.json
            fi
          else
            echo "❌ V1 schema not found at api-reference/v1/openapi_spec_v1.json"
            echo "{}" > pr-v1-schema.json
          fi
          
          if [[ -f "api-reference/v2/openapi_spec_v2.json" ]]; then
            # Validate JSON before copying
            if jq empty api-reference/v2/openapi_spec_v2.json 2>/dev/null; then
              cp api-reference/v2/openapi_spec_v2.json pr-v2-schema.json
              echo "✅ V2 schema: $(wc -c < pr-v2-schema.json) bytes (valid JSON)"
            else
              echo "❌ V2 schema contains invalid JSON"
              echo "{}" > pr-v2-schema.json
            fi
          else
            echo "❌ V2 schema not found at api-reference/v2/openapi_spec_v2.json"
            echo "{}" > pr-v2-schema.json
          fi
          
          # Show schema file contents for debugging (first few lines)
          echo "Debugging - V1 schema file contents (first 3 lines):"
          head -3 pr-v1-schema.json || echo "No content to show"
          echo "Debugging - V2 schema file contents (first 3 lines):"
          head -3 pr-v2-schema.json || echo "No content to show"

      - name: Extract base branch schemas
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
        run: |
          echo "Extracting base branch ($BASE_REF) API schemas using git show..."
          
          # Extract schemas directly from git history (no checkout needed!)
          if git show "$BASE_SHA:api-reference/v1/openapi_spec_v1.json" > base-v1-schema.json 2>/dev/null; then
            echo "✅ V1 schema extracted from git: $(wc -c < base-v1-schema.json) bytes"
          else
            echo "⚠️ V1 schema not found in base, using empty schema"
            echo "{}" > base-v1-schema.json
          fi
          
          if git show "$BASE_SHA:api-reference/v2/openapi_spec_v2.json" > base-v2-schema.json 2>/dev/null; then
            echo "✅ V2 schema extracted from git: $(wc -c < base-v2-schema.json) bytes"
          else
            echo "⚠️ V2 schema not found in base, using empty schema"
            echo "{}" > base-v2-schema.json
          fi


      - name: Run breaking change detection
        id: breaking_changes
        run: |
          echo "Analyzing API changes for breaking changes..."

          BREAKING_CHANGES=0
          V1_HAS_BREAKING=0
          V2_HAS_BREAKING=0

          # Check V1 API changes
          echo "Checking V1 API for breaking changes..."
          V1_EXIT_CODE=0

          # Check if config files exist, use them if available
          OASDIFF_ARGS="--fail-on ERR"
          if [[ -f ".oasdiff-err-ignore.yaml" ]]; then
            OASDIFF_ARGS="$OASDIFF_ARGS --err-ignore .oasdiff-err-ignore.yaml"
          fi
          if [[ -f ".oasdiff-warn-ignore.yaml" ]]; then
            OASDIFF_ARGS="$OASDIFF_ARGS --warn-ignore .oasdiff-warn-ignore.yaml"
          fi

          oasdiff breaking $OASDIFF_ARGS \
            base-v1-schema.json pr-v1-schema.json > v1-breaking-report.txt 2>&1 || V1_EXIT_CODE=$?

          if [[ $V1_EXIT_CODE -eq 0 ]]; then
            echo "✅ No breaking changes in V1 API"
            echo "✅ V1 API is backward compatible" > v1-breaking-status.txt
          else
            # oasdiff failed - check if report has actual content (breaking changes)
            # If file is very small (< 50 bytes), it's likely just an error message
            REPORT_SIZE=$(wc -c < v1-breaking-report.txt 2>/dev/null || echo "0")
            if [[ $REPORT_SIZE -gt 50 ]] && grep -q "ERR" v1-breaking-report.txt 2>/dev/null; then
              echo "❌ Breaking changes detected in V1 API"
              echo "❌ Breaking changes detected in V1 API" > v1-breaking-status.txt
              V1_HAS_BREAKING=1
              cat v1-breaking-report.txt
            else
              echo "⚠️ V1 API check had issues but no breaking changes found"
              echo "✅ V1 API is backward compatible" > v1-breaking-status.txt
              cat v1-breaking-report.txt
            fi
          fi

          # Check V2 API changes
          echo "Checking V2 API for breaking changes..."
          V2_EXIT_CODE=0

          # Reuse the same args
          oasdiff breaking $OASDIFF_ARGS \
            base-v2-schema.json pr-v2-schema.json > v2-breaking-report.txt 2>&1 || V2_EXIT_CODE=$?

          if [[ $V2_EXIT_CODE -eq 0 ]]; then
            echo "✅ No breaking changes in V2 API"
            echo "✅ V2 API is backward compatible" > v2-breaking-status.txt
          else
            # oasdiff failed - check if report has actual content (breaking changes)
            REPORT_SIZE=$(wc -c < v2-breaking-report.txt 2>/dev/null || echo "0")
            if [[ $REPORT_SIZE -gt 50 ]] && grep -q "ERR" v2-breaking-report.txt 2>/dev/null; then
              echo "❌ Breaking changes detected in V2 API"
              echo "❌ Breaking changes detected in V2 API" > v2-breaking-status.txt
              V2_HAS_BREAKING=1
              cat v2-breaking-report.txt
            else
              echo "⚠️ V2 API check had issues but no breaking changes found"
              echo "✅ V2 API is backward compatible" > v2-breaking-status.txt
              cat v2-breaking-report.txt
            fi
          fi

          # Calculate total breaking changes
          BREAKING_CHANGES=$((V1_HAS_BREAKING + V2_HAS_BREAKING))

          echo "Final breaking changes count: $BREAKING_CHANGES"

          # Generate detailed diff reports
          echo "Generating detailed change reports..."
          oasdiff diff base-v1-schema.json pr-v1-schema.json > v1-detailed-diff.txt 2>/dev/null || true
          oasdiff diff base-v2-schema.json pr-v2-schema.json > v2-detailed-diff.txt 2>/dev/null || true

          echo "breaking_changes=$BREAKING_CHANGES" >> $GITHUB_OUTPUT
          echo "total_issues=$BREAKING_CHANGES" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Generate compatibility report
        id: report
        run: |
          # Use enhanced report generation script
          chmod +x ./scripts/generate-compatibility-report.sh
          ./scripts/generate-compatibility-report.sh > compatibility-report.md
          
          # Set output variables
          echo "report_generated=true" >> $GITHUB_OUTPUT
          
          if [[ "${BREAKING_CHANGES:-0}" -gt 0 ]]; then
            echo "validation_status=BREAKING CHANGES DETECTED" >> $GITHUB_OUTPUT
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          else
            echo "validation_status=ALL CHECKS PASSED" >> $GITHUB_OUTPUT
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          fi
        env:
          BREAKING_CHANGES: ${{ steps.breaking_changes.outputs.breaking_changes }}

      - name: Update PR comment
        if: always() && github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'validate-api')
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            
            // Read the compatibility report
            let report = '';
            if (fs.existsSync('compatibility-report.md')) {
              report = fs.readFileSync('compatibility-report.md', 'utf8');
            } else {
              report = 'Could not generate compatibility report. Please check the workflow logs.';
            }
            
            // Create the PR comment body
            const commentBody = `## API Compatibility Report
            
            **Status**: ${{ steps.report.outputs.validation_status || 'Unknown' }}
            
            ${report}
            
            ---
            *Automatically generated by the API Compatibility workflow.*`;
            
            // Find existing API compatibility comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.data.find(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('API Compatibility Report')
            );
            
            // Update existing comment or create new one
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
              console.log('Updated existing API compatibility comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new API compatibility comment');
            }

      - name: Fail if breaking changes detected
        if: steps.breaking_changes.outputs.breaking_changes != '0' && steps.breaking_changes.outputs.breaking_changes != ''
        run: |
          echo "::error::Breaking changes detected in API schema."
          echo "::error::Found ${{ steps.breaking_changes.outputs.breaking_changes }} breaking change(s)."
          echo "::error::Please review the compatibility report and consider:"
          echo "::error::- Creating a new API version (v3)"
          echo "::error::- Using backward-compatible changes instead"
          echo "::error::- Coordinating with API consumers before deployment"
          exit 1

      - name: Upload validation artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-validation-artifacts-${{ github.run_number }}
          path: |
            pr-v1-schema.json
            pr-v2-schema.json
            base-v1-schema.json
            base-v2-schema.json
            v1-breaking-report.txt
            v2-breaking-report.txt
            v1-detailed-diff.txt
            v2-detailed-diff.txt
            compatibility-report.md
            v1-breaking-status.txt
            v2-breaking-status.txt
          retention-days: 30


#add migration check here
  migration-compatibility-check:
    name: Migration Breaking Change Detection
    runs-on: ubuntu-latest

    # Run on all PRs that modify migration files
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          token: ${{ github.token }}

      - name: Fetch base branch
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
        run: |
          git fetch origin "$BASE_REF:$BASE_REF"

      - name: Validate migrations for breaking changes
        id: migration_check
        run: |
          echo "Running migration validation..."

          # Make script executable
          chmod +x ./scripts/validate-migrations.sh

          # Run validation for main migrations directory
          ./scripts/validate-migrations.sh "migrations" "origin/${{ github.event.pull_request.base.ref }}" > migration-report.txt 2>&1 || MIGRATION_EXIT_CODE=$?

          # Store results
          BREAKING_COUNT=$(cat migration-breaking-count.txt 2>/dev/null || echo "0")
          WARNING_COUNT=$(cat migration-warning-count.txt 2>/dev/null || echo "0")

          echo "breaking_changes=$BREAKING_COUNT" >> $GITHUB_OUTPUT
          echo "warnings=$WARNING_COUNT" >> $GITHUB_OUTPUT

          # Display report
          cat migration-report.txt

          # Exit with appropriate code
          if [[ $BREAKING_COUNT -gt 0 ]]; then
            exit 1
          fi
        continue-on-error: true

      - name: Check v2_migrations if exists
        id: v2_migration_check
        run: |
          if [[ -d "v2_migrations" ]]; then
            echo "Running validation for v2_migrations..."

            ./scripts/validate-migrations.sh "v2_migrations" "origin/${{ github.event.pull_request.base.ref }}" > v2-migration-report.txt 2>&1 || V2_EXIT_CODE=$?

            V2_BREAKING_COUNT=$(cat migration-breaking-count.txt 2>/dev/null || echo "0")
            V2_WARNING_COUNT=$(cat migration-warning-count.txt 2>/dev/null || echo "0")

            echo "breaking_changes=$V2_BREAKING_COUNT" >> $GITHUB_OUTPUT
            echo "warnings=$V2_WARNING_COUNT" >> $GITHUB_OUTPUT

            cat v2-migration-report.txt

            if [[ $V2_BREAKING_COUNT -gt 0 ]]; then
              exit 1
            fi
          else
            echo "v2_migrations directory not found, skipping..."
            echo "breaking_changes=0" >> $GITHUB_OUTPUT
            echo "warnings=0" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Check v2_compatible_migrations if exists
        id: v2_compatible_migration_check
        run: |
          if [[ -d "v2_compatible_migrations" ]]; then
            echo "Running validation for v2_compatible_migrations..."

            ./scripts/validate-migrations.sh "v2_compatible_migrations" "origin/${{ github.event.pull_request.base.ref }}" > v2-compatible-migration-report.txt 2>&1 || V2_COMPAT_EXIT_CODE=$?

            V2_COMPAT_BREAKING_COUNT=$(cat migration-breaking-count.txt 2>/dev/null || echo "0")
            V2_COMPAT_WARNING_COUNT=$(cat migration-warning-count.txt 2>/dev/null || echo "0")

            echo "breaking_changes=$V2_COMPAT_BREAKING_COUNT" >> $GITHUB_OUTPUT
            echo "warnings=$V2_COMPAT_WARNING_COUNT" >> $GITHUB_OUTPUT

            cat v2-compatible-migration-report.txt

            if [[ $V2_COMPAT_BREAKING_COUNT -gt 0 ]]; then
              exit 1
            fi
          else
            echo "v2_compatible_migrations directory not found, skipping..."
            echo "breaking_changes=0" >> $GITHUB_OUTPUT
            echo "warnings=0" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Generate migration compatibility report
        id: migration_report
        run: |
          # Calculate total breaking changes and warnings
          TOTAL_BREAKING=$((
            ${MIGRATION_BREAKING:-0} +
            ${V2_MIGRATION_BREAKING:-0} +
            ${V2_COMPAT_MIGRATION_BREAKING:-0}
          ))

          TOTAL_WARNINGS=$((
            ${MIGRATION_WARNINGS:-0} +
            ${V2_MIGRATION_WARNINGS:-0} +
            ${V2_COMPAT_MIGRATION_WARNINGS:-0}
          ))

          # Create comprehensive report
          cat > migration-compatibility-report.md <<'EOF'
          ### 🗄️ Database Migration Analysis

          #### Summary
          - **Breaking Changes**: ${TOTAL_BREAKING}
          - **Warnings**: ${TOTAL_WARNINGS}

          #### Main Migrations
          $(cat migration-report.txt 2>/dev/null || echo "No changes detected")

          #### V2 Migrations
          $(cat v2-migration-report.txt 2>/dev/null || echo "No v2_migrations directory found")

          #### V2 Compatible Migrations
          $(cat v2-compatible-migration-report.txt 2>/dev/null || echo "No v2_compatible_migrations directory found")

          ---

          #### ⚠️ Migration Best Practices
          - ✅ Use `ADD COLUMN` instead of modifying existing columns
          - ✅ Make new columns nullable or provide defaults
          - ✅ Create new tables/indexes before removing old ones
          - ✅ Test migrations with production-like data volumes
          - ✅ Ensure down migrations can rollback changes
          - ❌ Avoid `DROP TABLE`, `DROP COLUMN` in production migrations
          - ❌ Avoid `ALTER COLUMN TYPE` that may cause data loss
          - ❌ Avoid removing enum values that are in use
          EOF

          # Process the template
          eval "echo \"$(cat migration-compatibility-report.md)\"" > migration-compatibility-report.md

          echo "total_breaking=$TOTAL_BREAKING" >> $GITHUB_OUTPUT
          echo "total_warnings=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT

          if [[ $TOTAL_BREAKING -gt 0 ]]; then
            echo "validation_status=BREAKING CHANGES DETECTED" >> $GITHUB_OUTPUT
          elif [[ $TOTAL_WARNINGS -gt 0 ]]; then
            echo "validation_status=WARNINGS FOUND" >> $GITHUB_OUTPUT
          else
            echo "validation_status=ALL CHECKS PASSED" >> $GITHUB_OUTPUT
          fi
        env:
          MIGRATION_BREAKING: ${{ steps.migration_check.outputs.breaking_changes }}
          MIGRATION_WARNINGS: ${{ steps.migration_check.outputs.warnings }}
          V2_MIGRATION_BREAKING: ${{ steps.v2_migration_check.outputs.breaking_changes }}
          V2_MIGRATION_WARNINGS: ${{ steps.v2_migration_check.outputs.warnings }}
          V2_COMPAT_MIGRATION_BREAKING: ${{ steps.v2_compatible_migration_check.outputs.breaking_changes }}
          V2_COMPAT_MIGRATION_WARNINGS: ${{ steps.v2_compatible_migration_check.outputs.warnings }}

      - name: Update PR comment with migration report
        if: always() && github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'validate-api')
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');

            // Read the migration compatibility report
            let report = '';
            if (fs.existsSync('migration-compatibility-report.md')) {
              report = fs.readFileSync('migration-compatibility-report.md', 'utf8');
            } else {
              report = 'Could not generate migration compatibility report. Please check the workflow logs.';
            }

            // Create the PR comment body
            const commentBody = `## Migration Compatibility Report

            **Status**: ${{ steps.migration_report.outputs.validation_status || 'Unknown' }}

            ${report}

            ---
            *Automatically generated by the API Compatibility workflow.*`;

            // Find existing migration compatibility comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('Migration Compatibility Report')
            );

            // Update existing comment or create new one
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
              console.log('Updated existing migration compatibility comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new migration compatibility comment');
            }

      - name: Fail if migration breaking changes detected
        if: steps.migration_report.outputs.total_breaking != '0' && steps.migration_report.outputs.total_breaking != ''
        run: |
          echo "::error::Breaking changes detected in database migrations."
          echo "::error::Found ${{ steps.migration_report.outputs.total_breaking }} breaking change(s)."
          echo "::error::Please review the migration compatibility report and consider:"
          echo "::error::- Using additive-only migrations (ADD COLUMN, CREATE TABLE)"
          echo "::error::- Creating a data migration plan for destructive changes"
          echo "::error::- Coordinating with DevOps for zero-downtime deployment"
          echo "::error::- Ensuring proper rollback migrations are in place"
          exit 1

      - name: Upload migration validation artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-validation-artifacts-${{ github.run_number }}
          path: |
            migration-report.txt
            v2-migration-report.txt
            v2-compatible-migration-report.txt
            migration-compatibility-report.md
            migration-breaking-count.txt
            migration-warning-count.txt
          retention-days: 30
